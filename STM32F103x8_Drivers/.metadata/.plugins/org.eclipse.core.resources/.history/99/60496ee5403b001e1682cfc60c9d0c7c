/*
 * USART.c
 *
 *  Created on: Aug 14, 2023
 *      Author: ARAFA
 */


#include"USART.h"
#include"RCC.h"
#include"EXTI_driver.h"

//Generic ptr to be used in funcs
UART_Config * GP_UART_Config = NULL;



/**================================================================
 * @Fn					- MCAL_UART_Init
 * @brief 				- Initializes UART (Supported feature : ASYNCHRONOUS only)
 * @param [in] 			- USARTx: where x can be (1..3) depending on the device used
 * @param [in] 			- UARTCfg: All the UART configurations
 * @retval 				- None
 * Note					- The driver supports Asynchronous mode & HSI clock 8 Mhz
 */

void MCAL_UART_Init(USART_typedef* USARTx, UART_Config * UARTCfg){
	GP_UART_Config = UARTCfg;    //Backup

	uint32_t BRR,PCLCK;

	//Enable clock
	if(USARTx == USART1){
		RCC_USART1_CLK_Enable();
	}else if (USARTx == USART2){
		RCC_USART2_CLK_Enable();
	}else if(USARTx == USART3){
		RCC_USART3_CLK_Enable();
	}

	//Enable usart UE bit in USART_CR1
	USARTx->CR1 |= (1<<13);

	//programin M Bit in USART_CR1
	USARTx->CR1 |= UARTCfg->Word_Lenght;

	//stop Bits
	USARTx->CR2 |= UARTCfg->StopBits;

	//select desired buadrate
	if(USARTx == USART1){
		PCLCK = MCAL_RCC_GetPCLK2_CLCKFreq();
	}else if (USARTx == USART2){
		PCLCK = MCAL_RCC_GetPCLK1_CLCKFreq();
	}
	BRR = UART_BRR_Register(PCLCK,UARTCfg->BuadRate);
	USARTx->BRR = BRR;

	//select desired stop bit
	USARTx->CR2 |= UARTCfg->StopBits;

	//Select Parity bit
	USARTx->CR1 |= UARTCfg->Parity;

	//Select HWFlow CTRl
	USARTx->CR3 |= UARTCfg->HWFlowCtl;

	//select TX/Rx MOde
	USARTx->CR1 |= UARTCfg->USART_Mode;

	//select between interrupt and polling
	if(UARTCfg->IRQEnable != UART_IRQ_Enable_NONE){

		USARTx->CR1 |= UARTCfg->IRQEnable;

		if(USARTx == USART1){
			NVIC_USART1_IRQ_Enable;
		}else if (USARTx == USART2){
			NVIC_USART2_IRQ_Enable;
		}else if(USARTx == USART3){
			NVIC_USART3_IRQ_Enable;
		}
	}
}



/**================================================================
 * @Fn					- MCAL_UART_DeInit
 * @brief 				- DeInitializes UART (Supported feature : ASYNCHRONOUS only)
 * @param [in] 			- USARTx: where x can be (1..3) depending on the device used
 * @retval 				- None
 * Note					- Resets the USART module using RCC Reset registers
 */

void MCAL_UART_DeInit(USART_typedef* USARTx){
	if(USARTx == USART1){
			RCC_USART1_CLK_Disable();
			NVIC_USART1_IRQ_Disable;

	}else if (USARTx == USART2){
			RCC_USART2_CLK_Disable();
			NVIC_USART2_IRQ_Disable;

	}else if(USARTx == USART3){
			RCC_USART3_CLK_Disable();
			NVIC_USART3_IRQ_Disable;
		}
}



void MCAL_UART_GPIO_SetPins(USART_typedef* USARTx);



/**================================================================
 * @Fn					- MCAL_UART_SendData
 * @brief 				- Send buffer on UART
 * @param [in] 			- USARTx: where x can be (1..3) depending on the device used
 * @param [in] 			- pTxBuffer: buffer
 * @param [in]			- PollingEn: Enable polling or not
 * @retval 				- None
 * Note					- When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register),
							the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect
							because it is replaced by the parity.
							When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
 */
void MCAL_UART_SendDate(USART_typedef* USARTx, uint16_t* pTXBuffer, enum polling_Mechanism PollingState){

	//wait till TXE is set
	if(PollingState == Enable){
		while(!(USARTx->SR & 1<<7));
	}

	//check the word lenght
	if(GP_UART_Config ->Word_Lenght == UART_Word_Lenght_8B){
		USARTx->DR = (*pTXBuffer & (uint8_t)0xFF);
	}else{
		USARTx->DR = (*pTXBuffer & (uint16_t)0x01FF);
	}
}



/**================================================================
 * @Fn					- MCAL_UART_ReceiveData
 * @brief 				- Send buffer on UART
 * @param [in] 			- USARTx: where x can be (1..3) depending on the device used
 * @param [in] 			- pRxBuffer: buffer
 * @param [in]			- PollingEn: Enable polling or not
 * @retval 				- None
 * Note					- When transmitting with the parity enabled (PCE bit set to 1 in the USART_CR1 register),
							the value written in the MSB (bit 7 or bit 8 depending on the data length) has no effect
							because it is replaced by the parity.
							When receiving with the parity enabled, the value read in the MSB bit is the received parity bit.
 */

void MCAL_UART_RecieveDate(USART_typedef* USARTx, uint16_t* pTXBuffer, enum polling_Mechanism PollingState){

}



/**================================================================
 * @Fn					- MCAL_UART_WAIT_TC
 * @brief 				- Waits until the last buffer is sent
 * @param [in] 			- USARTx: where x can be (1..3) depending on the device used
 * @retval 				- None
 * Note					- None
 */
void MCAL_UART_WAIT_TC(USART_typedef* USARTx){

	//wait till TC Flag is set
	while(!(USARTx->SR & 1<<6));

}
